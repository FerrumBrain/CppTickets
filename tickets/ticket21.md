## 21. Функции-члены (методы)

* ## Синтаксис объявления и вызова через `.` или `->`.

[Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2021)
[Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/01-struct.cpp)

**Функция-член** (англ. _member function_, жарг. _метод_) - функция, которая позволяет работать с объектом и всеми его полями класса, в котором объявлена ==ЕГОР НЕ ДАЛ ОПРЕДЕЛЕНИЯ==

Синтаксис объявления - написали обычную функцию, но внутри структуры

```c++
struct Point {
    // members
    int x, y;

    // member function
    int dist2() {
        return x * x + y * y;
    }
}
```

(А ещё можно объявить в структуре, а определить потом вообще в другом месте, смотри последний пункт билета)

К функции добавляется аргумент, который не видно (_неявный аргумент_) `this`, смотри ниже. 

Синтаксис вызова через `.`:

```c++
...
Point p;
p.x = 10;
p.y = 20;
std::cout << p.dist2() << "\n";
...
```

По сути это просто вызов метода от объекта.

Синтаксис вызова через `->`:

Данный момент в лекции ==НЕ ОБНАРУЖЕН==
Соответствующий файл ==НЕ ОБНАРУЖЕН==

```c++
...
Point *p2 = &p;
std::cout << p2->dist2() << "\n";
```

По сути `p2->dist2()` это просто обёртка над `(*p2).dist2()`

* ## Ключевое слово `this`

[Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2054)

К функции добавляется аргумент, который не видно (_неявный аргумент_) `this` - объект (==указатель на объект!==), на которой этот метод был вызван.

В отличие от питона (в котором аргумент `self` явный), к полям можно обращаться просто по именам (вместо `self.x` в том же питоне)

[Более подробно про `this`](https://youtu.be/ZStm-I4K0so?t=4529)

`this` - в любом методе (именно методе, `friend` и `static` не методы) объект, на котором мы вызываем метод, **указатель** на структуру, в которой работаем.

  * ### Где его можно не писать, зачем писать хоть где-то.
  
  Можно не писать при обращении к полям объекта, в методе от которого мы работаем. 
  
  ==ИСТОЧНИК ОТСУТСТВУЕТ==
  Писать нужно, когда мы в методе хотим, например, закинуть куда-нибудь ссылку на себя, например при реализации двусвязного списка:
  
```c++
struct node {
	int value;
	node *prev; 
    node *next;
    
    void append_right(node *child) {
        next = child;
        child->prev = this;
    }

    void append_left(node *child) {
        prev = child;
        child->next = this;
    }
};
```
  
  * ### Чем метод отличается от свободной функции.
  
  [Данный момент в лекции](https://youtu.be/ZStm-I4K0so?t=4395)
  
  Методы объявляются в структуре, могут рекурсивно вызываться друг из друга без необходимости предварительного объявления (т.к. внутри структур совместимости с `C` уже нет, можно жить в два прохода):
  
```c++
struct Foo{
  void foo() {
    bar();
  }
    
  void bar() {
    foo();
  }
};
```
  
  Метод - функция-член, находится в структуре, ей же и принадлежит. Сразу же имеет доступ к приватным полям (да и вообще к `this`)
  
  Свободная функция - функция, не находящаяся в какой-либо структуре, не имеет доступа к приватным полям
  
  А ещё есть `friend` функции, которые могут быть определены снаружи, но при этом иметь доступ к приватным полям. Методами не являются, по сути -- свободные функции
  
  А ещё есть `static` функции, которые всё ещё `friend`, которые всё ещё не методы, но она лежит внутри класса (с точки зрения имени)
  
  * ### Захват `this` в лямбды: `[]`, `[=]`, `[&]`, `[this]`, `[*this]`
  
  Будем рассматривать следующую ситуацию:
  
```c++
struct Foo {
    int member_var = 10;
    static inline int static_member_var = 20;
    int arr[10'000];

    void method() {
        int local_var = 30;
        static int static_local_var = 40;
        [[maybe_unused]] long long local_big[100]{};
    }
};
```
  
* ## Const correctness: ограничение доступа к полям (в том числе ссылочным и указателям) при константном `this`.

  * ### Когда возникает константный `this`.
  
  [Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2372)
  [Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/02-const.cpp)
  
  Пусть у нас есть функция, которая принимает объект по константной ссылке (чтобы не менять и не копировать объект):
  
```c++
  void print(const Point &p) {
      std::cout << p.x << " " << p.y << "\n";
      std::cout << p.dist2() << "\n";
  }
```
  
  Если `dist2` реализован так, как мы его описывали ранее:
  
```c++
  struct Point {
      ... 
      int dist2() {
          return x * x + y * y;
      }
  }
```
  
  То данный код не скомпилируется с ошибкой вида `error: passing 'const Point' as 'this' argument discards qualifiers`
  
  `p` - `const Point`, `this` - объект, на котором работаем. Компилятор по умолчанию считает, что любой метод меняет объект.
  Как итог: компилятор видит, что метод `dist2` меняет объект, значит его нельзя вызывать на константном `this`.

  
  * ### Const qualifier и ограничения внутри такого метода.
  
  Сам компилятор посмотреть на тело метода и понять, что ничего не меняется, не может (реализация может быть вообще в другом месте, например).
  
  В таком случае мы сами должны указать компилятору, что метод не меняет объект - добавить `const` qualifier:
  
```c++
int dist2() const {
    return x * x + y * y;
}
```

   Теперь компилятор разрешает вызывать этот метод на константных объектах, и при компиляции данного метода компилятор проверит, что метод не изменяет ни одно из полей.
   
   Общее правило: если вы можете сделать какой-то метод константным - сделайте. 
  
  * ### Когда будет UB при отбрасывании const qualifier внутри метода.
  
  Пусть у меня `dist2` не константный, но я очень хочу вызвать его на константном объекте. Можно попробовать взять неконстантную ссылку на объект и вызвать метод от неё.
  
  Если брать ссылку тупым образом `Point &p2 = p`, то произойдёт падение на этапе компиляции: `error: binding reference of type 'Point&' to 'const Point' discards qualifiers`
  
  Но мы знаем про приведение типов и C-style cast.
  
```c++
void print(const Point &p) {
    std::cout << p.x << " " << p.y << "\n";

    Point &p2 = (Point&)p;
    std::cout << p2.dist2() << "\n";
}
```

  Вообще C-style cast-ом пользоваться не нужно, он творит хрень. Он и сейчас сотворит хрень, но прямо сейчас это **не UB**, потому что наш метод **действительно ничего не меняет** и исходная точка `p`, которую мы передали в функцию, была не константной.
  
  А вот если, например, сделать так (объявить точку `p` константной):
  
```c++
int main() {
...
    const Point const_p{30, 40};
    print(const_p);
}
```

  И вот теперь начинается **UB**
  
  Запрещается вызывать неконстантные методы на исходно константных объектах.
  
  Объяснение: константные объекты могут храниться в памяти, в которую ничего нельзя записывать, это может быть другое адресное пространство и неконстантному методу будет плохо.
  
  А `static_cast` просто не скомпилируется, используйте `static_cast`. А ещё существует `const_cast`, который позволяет отбрасывать константность. Но он заметный и почти не возникает в реальности.
  
  Итог: при отбрасывании `const`-квалификатора произойдёт **UB** если

  1) Исходный объект был сам по себе константным (тут точно произойдёт)
  2) Метод как-то изменяет поля объекта (а вот тут уже не факт, Егор сам не уверен)
  
* ## Ref qualifier `&`

Этого, судя по всему, не было совсем. Если вдруг это не так - сообщите.

* ## Определение методов внутри и снаружи класса, неявный `inline` и зачем.

==TODO== 