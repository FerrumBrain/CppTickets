## 21. Функции-члены (методы)

* ## Синтаксис объявления и вызова через `.` или `->`.

[Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2021)
[Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/01-struct.cpp)

**Функция-член** (англ. _member function_, жарг. _метод_) - функция, которая позволяет работать с объектом и всеми его полями класса, в котором определена ==ЕГОР НЕ ДАЛ ОПРЕДЕЛЕНИЯ==

Синтаксис объявления - написали обычную функцию, но внутри структуры

```c++
struct Point {
    // members
    int x, y;

    // member function
    int dist2() {
        return x * x + y * y;
    }
}
```

К функции добавляется аргумент, который не видно (_неявный аргумент_) `this`, смотри ниже. 

Синтаксис вызова через `.`:

```c++
...
Point p;
p.x = 10;
p.y = 20;
std::cout << p.dist2() << "\n";
...
```

По сути это просто вызов метода от объекта.

Синтаксис вызова через `->`:

```c++
TODO
```

По сути это ==TODO==

* ## Ключевое слово `this`

[Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2054)

К функции добавляется аргумент, который не видно (_неявный аргумент_) `this` - объект (==указатель на объект!==), на которой этот метод был вызван.

В отличие от питона (в котором аргумент `self` явный), к полям можно обращаться просто по именам (вместо `self.x` в том же питоне)

  * ### Где его можно не писать, зачем писать хоть где-то.
  
  Можно не писать при обращении к полям объекта, в методе от которого мы работаем. 
  
  * ### Чем метод отличается от свободной функции.
  
  ==TODO==
  
  * ### Захват `this` в лямбды: `[]`, `[=]`, `[&]`, `[this]`, `[*this]`
  
  ==TODO==
  
* ## Const correctness: ограничение доступа к полям (в том числе ссылочным и указателям) при константном `this`.

  * ### Когда возникает константный `this`.
  
  [Данный момент в лекции](https://youtu.be/Ff1pBiDkPOA?t=2372)
  [Соответствующий файл](https://github.com/hse-spb-2021-cpp/lectures/blob/master/03-210916/02-struct/02-const.cpp)
  
  Пусть у нас есть функция, которая принимает объект по константной ссылке (чтобы не менять и не копировать объект):
  
  ```c++
  void print(const Point &p) {
      std::cout << p.x << " " << p.y << "\n";
      std::cout << p.dist2() << "\n";
  }
  ```
  
  Если `dist2` реализован так, как мы его описывали ранее:
  
  ```c++
  struct Point {
      ... 
      int dist2() {
          return x * x + y * y;
      }
  }
  ```
  
  То данный код не скомпилируется с ошибкой вида `error: passing 'const Point' as 'this' argument discards qualifiers`
  
  `p` - `const Point`, `this` - объект, на котором работаем. Компилятор по умолчанию считает, что любой метод меняет объект.
  Как итог: компилятор видит, что метод `dist2` меняет объект, значит его нельзя вызывать на константном `this`.

  
  * ### Const qualifier и ограничения внутри такого метода.
  
  Сам компилятор посмотреть на тело метода и понять, что ничего не меняется, не может (реализация может быть вообще в другом месте, например).
  
  В таком случае мы сами должны указать компилятору, что метод не меняет объект - добавить `const` qualifier:
  
  ```c++
int dist2() const {
    return x * x + y * y;
}
```

   Теперь компилятор разрешает вызывать этот метод на константных объектах, и при компиляции данного метода компилятор проверит, что метод не изменяет ни одно из полей.
   
   Общее правило: если вы можете сделать какой-то метод константным - сделайте. 
  
  * ### Когда будет UB при отбрасывании const qualifier внутри метода.
  
  Пусть у меня `dist2` не константный, но я очень хочу вызвать его на константном объекте. Можно попробовать взять неконстантную ссылку на объект и вызвать метод от неё.
  
  Если брать ссылку тупым образом `Point &p2 = p`, то произойдёт падение на этапе компиляции: `error: binding reference of type 'Point&' to 'const Point' discards qualifiers`
  
  Но мы знаем про приведение типов и C-style cast.
  
  ```c++
void print(const Point &p) {
    std::cout << p.x << " " << p.y << "\n";

    Point &p2 = (Point&)p;
    std::cout << p2.dist2() << "\n";
}
```

  Вообще C-style cast-ом пользоваться не нужно, он творит хрень. Он и сейчас сотворит хрень, но прямо сейчас это **не UB**, потому что наш метод **действительно ничего не меняет** и исходная точка `p`, которую мы передали в функцию, была не константной.
  
  А вот если, например, сделать так (объявить точку `p` константной):
  
  ```c++
int main() {
...
    const Point const_p{30, 40};
    print(const_p);
}
```

  И вот теперь начинается **UB**
  
  Запрещается вызывать неконстантные методы на исходно константных объектах.
  
  Объяснение: константные объекты могут храниться в памяти, в которую ничего нельзя записывать, это может быть другое адресное пространство и неконстантному методу будет плохо.
  
  А `static_cast` просто не скомпилируется, используйте `static_cast`. А ещё существует `const_cast`, который позволяет отбрасывать константность. Но он заметный и почти не возникает в реальности.
  
* ## Ref qualifier `&`

==TODO==

* ## Определение методов внутри и снаружи класса, неявный `inline` и зачем.

==TODO== 